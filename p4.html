<!doctype html> 
<html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>BallJumper - WASD + Space</title>
    <style>
      body { margin: 0; } canvas { width: 100%;
      height: 100% }
    </style>
  </head>
  <body>
    <script src="js/three.min.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/SourceLoader.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/KeyboardState.js"></script> <!-- By Jerome Etienne: http://jetienne.com/ -->
    <script src="PlayerMesh.js"></script>
    <script src="PlatformMesh.js"></script>
    <script>
    // CPSC 314 Final project: 
// Game name: BallJumper

var scene = new THREE.Scene();

// setting up renderer
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor(0xBBBBBBB);
document.body.appendChild(renderer.domElement);

renderer.shadowMapEnabled = true;
renderer.shadowMapSoft = true;


  // setting up window resize and adaptation
function resize() {
  windowWidth = window.innerWidth;
  windowHeight = window.innerHeight;
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// add player
var playerSize = 10;
var geometry = new THREE.SphereGeometry(playerSize, 32, 32);
var material = new THREE.MeshBasicMaterial( {wireframe: true, opacity: 0.0, transparent: true})
var player = new THREE.PlayerMesh(geometry, material);
player.position.set(0,100,0);
scene.add(player);

// add ball
var ballSize = 10;
var geometry = new THREE.SphereGeometry(ballSize, 32, 32);
var material = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('img/game/ballTexture.jpg') } );
var ball = new THREE.Mesh(geometry, material);
ball.position.set(0,0,0);
ball.castShadow = true;
player.add(ball);

// // add particle
// var particleSize = 10;
// var geometry = new THREE.SphereGeometry(ballSize, 32, 32);
// var material = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('img/game/ballTexture.jpg') } );
// var particle = new THREE.Mesh(geometry, material);
// particle.position.set(75,50,-75);
// scene.add(particle);


//directional light
var directionalLight = new THREE.DirectionalLight(0xffffff);
directionalLight.position.set(50000, 100000, 50000);
directionalLight.lookAt(player.position); 

directionalLight.castShadow = true;
directionalLight.shadowDarkness = 0.75;
directionalLight.shadowCameraVisible = true;

directionalLight.shadowCameraNear = 10000;
directionalLight.shadowCameraFar = 150000;

directionalLight.shadowCameraLeft = -1000;
directionalLight.shadowCameraRight = 1000;
directionalLight.shadowCameraTop = 1000;
directionalLight.shadowCameraBottom = -1000;
  
player.add(directionalLight);


var ambLight = new THREE.AmbientLight(0xBBBBBB); // soft white light
ambLight.visible = false;
scene.add( ambLight );


// EVENT LISTENER RESIZE
window.addEventListener('resize',resize);
resize();

// setting up the camera:
var aspect = window.innerWidth/window.innerHeight;
var camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 20000);
camera.position.set(100,250,350);
camera.lookAt(scene.position); 
player.add(camera);

// setting controls
var controls = new THREE.OrbitControls(camera);
controls.enableDamping = true;
controls.dampingFactor = 0.25;
controls.enableZoom = false;

// array to track allObstacles
var allObstacles = [];

// floor from p3 used
var floorTexture = new THREE.ImageUtils.loadTexture( 'img/game/grass2.jpg' );
floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
floorTexture.repeat.set(8,8);
var floorMaterial = new THREE.MeshPhongMaterial( { map: floorTexture, side: THREE.DoubleSide } );
var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
var floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.position.y = -1 + playerSize;
floor.rotation.x = Math.PI / 2;
floor.receiveShadow = true
;scene.add(floor);
floor.receiveShadow = true;
allObstacles.push(floor);

//starting obstacle
var cube = makePlatform();
cube.position.set(100,30,0);
scene.add(cube);
allObstacles.push(cube);

var cube = makePlatform();
cube.position.set(-100,30,0);
scene.add(cube);
allObstacles.push(cube);

var cube = makePlatform();
cube.position.set(0,150,0);
scene.add(cube);
allObstacles.push(cube);


// adding an object
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock(true);


function keyboardCallBack() {
   var delta = clock.getDelta();
   var distanceMoved = 100 * delta;
   var angleRotated = distanceMoved/player.size;


   if(keyboard.pressed("W")  && player.collisions.z != -1){
    player.translateZ(-distanceMoved);
    ball.rotateX(-angleRotated);
   }
   if(keyboard.pressed("A") && player.collisions.x != -1){
    player.translateX(-distanceMoved);
    ball.rotateZ(angleRotated);
   }
   if(keyboard.pressed("S")  && player.collisions.z != 1){
      player.translateZ (distanceMoved);
      ball.rotateX(angleRotated);
   }
   if(keyboard.pressed("D") && player.collisions.x != 1){
    player.translateX(distanceMoved);
    ball.rotateZ(-angleRotated);   
  }
}

function onKeyDown(event) {
  if(keyboard.eventMatches(event,"space")){
    player.jump();
  }
  if(keyboard.eventMatches(event,"L")){
    directionalLight.visible = !directionalLight.visible;
    ambLight.visible = !ambLight.visible;
  }
}
keyboard.domElement.addEventListener('keydown', onKeyDown );

function moveAllPlatforms() {
  // the 0th obstacle is the floor, so start from 1
  for (i = 1; i <= allObstacles.length -1; i++) {
    allObstacles[i].movePlatform();
  }
}

//add new platform when player reaches the highest platform
function addNewPlatform() {
  
  var platPos = allObstacles[allObstacles.length-1].position
  var platSize = 40;

  //only add new platform if player lands on the highest playform
  if ( (Math.abs(player.position.y - platPos.y - platSize + player.size) <= 0.001) &&
    (Math.abs(player.position.x - platPos.x) <= platSize) && 
    (Math.abs(player.position.z - platPos.z) <= platSize) &&
    (player.velocity.y == 0) ) {

    var cube = makePlatform();

    var newPos = newPlatformPosition();
    cube.position.set(newPos.x,newPos.y,newPos.z);
    allObstacles.push(cube);
    scene.add(cube);
  }
}

function makePlatform() {
    var geometry = new THREE.BoxGeometry( 100, 40, 100 );
    var material = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('img/game/crate.jpg') } );
    var cube = new THREE.PlatformMesh( geometry, material );
    cube.castShadow = true;
    cube.receiveShadow = true;

    return cube;
}

// generates position of the new platform using the current highest platform
function newPlatformPosition() {
  //position of the highest platform
  var platPos = allObstacles[allObstacles.length-1].position;

  var radius = Math.random()*100 + 50;
  var angle1 = Math.random()*360;https://www.facebook.com/#

  var x = radius * Math.cos(angle1);
  var z = radius * Math.sin(angle1);

  var y;
  if (radius > 160) {
    y = Math.random()* 50 + 75 + platPos.y;
  } else if (radius > 120){
    y = Math.random()* 40 + 100 + platPos.y;
  } else if (radius > 75) {
    y = Math.random()* 60 + 100 + platPos.y;
  } else {
    y = Math.random()* 45 + 125 + platPos.y; 
  }

  return new THREE.Vector3(x,y,z);
}


var render = function() {
 player.updatePosition();
 keyboardCallBack();
 addNewPlatform();
 moveAllPlatforms()
 cube.movePlatform();
 requestAnimationFrame(render);
 renderer.render(scene, camera);
};

render();

    </script>
  </body>
</html>